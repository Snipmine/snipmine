package org.snipcloud.server;


import java.security.Principal;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Random;

import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.digest.DigestUtils;
import org.snipcloud.core.User;

import com.google.common.primitives.Bytes;

public class Account implements Principal {
	private User user;
	
	private byte[] passwordHash;
	private byte[] passwordSalt;
	private boolean verified;
	private String verificationToken;

	
	public Account(User user, byte[] passwordHash, byte[] passwordSalt, boolean verified, String verificationToken) {
		this.user = user;
		this.passwordHash = passwordHash;
		this.passwordSalt = passwordSalt;
		this.verified = verified;
		this.verificationToken = verificationToken;
	}
	
	public Account(User user, byte[] passwordHash, byte[] passwordSalt) {
		this(user, passwordHash, passwordSalt, true, null);
	}
	
	public User getUser() {
		return user;
	}
	
	public long getId() {
		return user.getId();
	}
	
	public boolean isVerified() {
		return verified;
	}
	
	public String getVerificationToken() {
		return verificationToken;
	}
	

	/**
	 * Generates a (secure) random 20-byte salt
	 * @return the 20-byte salt
	 * @note The salt should be at least 16 bytes and at most the length of the hash digest.
	 */
	public static byte[] generateSalt() {
		Random r = new SecureRandom();
		byte salt[] = new byte[20];
		r.nextBytes(salt);
		return salt;
	}
	
	/**
	 * Computes the hash for a given salt and password string
	 * @param salt		The salt, as generated by generateSalt
	 * @param password	The password as string
	 * @return			The password hash. SHA-1 in this case.
	 */
	public static byte[] calculatePasswordHash(byte[] salt, String password) {
		return DigestUtils.sha(Bytes.concat(salt, password.getBytes()));
	}
	
	/**
	 * Checks if the password supplied matches the password for this account
	 * @param password	The password, that is to be checked, as string
	 * @return			If the password matches the account "stored password"
	 */
	public boolean checkPassword(String password) {
		byte c[] = calculatePasswordHash(passwordSalt, password);
		return Arrays.equals(passwordHash, c);
	}
	
	public boolean isUserInRole(String role) {
		/* TODO: store in database */
		return role.equals("user");
	}

	@Override
	public String getName() {
		return user.getUsername();
	}

	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((user == null) ? 0 : user.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Account other = (Account) obj;
		if (user == null) {
			if (other.user != null)
				return false;
		} else if (!user.equals(other.user))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "Account [user=" + user + ", verified=" + verified + "]";
	}

	public static String generateVerificationToken() {
		byte[] token = generateSalt();
		return new String(Hex.encodeHex(token));
	}

}
